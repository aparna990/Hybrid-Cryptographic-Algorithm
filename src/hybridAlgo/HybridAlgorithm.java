package hybridAlgo;
import java.io.*;
import java.util.Random;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;

import javax.crypto.KeyAgreement;

public class HybridAlgorithm {

	//Big Integer  - > Java class to perform operations on Integers of arbitrary precision
	BigInteger p;
	BigInteger q;
	BigInteger N;
	BigInteger e;
	BigInteger d;
	BigInteger phiN;
	Random r;
	int bitlen = 1024;
	int flag=0;
	
	public HybridAlgorithm() throws Exception 
	{
		r = new Random();
		p = BigInteger.probablePrime(bitlen, r);
		q = BigInteger.probablePrime(bitlen, r);
		
		N = p.multiply(q);
		phiN = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));
	
	do{
		try
		{
		flag=0;
		e = ECDH_KeyGen();
		d = e.modInverse(phiN);
		
		}
		catch(ArithmeticException e)
		{
			//System.out.println("Error in Mod Inverse!"+e);
			flag=1;
		}
	}while(flag==1);
		
		
		System.out.println("The Key Generated by ECDH ( E )  : "+ e.toString(16));
		System.out.println("The Key Generated by ECDH ( D )  : "+ d.toString(16));
		
	}
	
	public static BigInteger ECDH_KeyGen() throws Exception
	{
		KeyPairGenerator kpg;
		kpg = KeyPairGenerator.getInstance("EC","SunEC");
		ECGenParameterSpec ecsp;
		
		ecsp = new ECGenParameterSpec("secp192r1");
		kpg.initialize(ecsp);
		
		KeyPair kpU = kpg.generateKeyPair();
		PrivateKey privkeyU = kpU.getPrivate();
		PublicKey pubkeyU = kpU.getPublic();
		
		System.out.println("User U : "+privkeyU.toString());
		System.out.println("User U : "+pubkeyU.toString());
		
		KeyPair kpV = kpg.generateKeyPair();
		PrivateKey privkeyV = kpV.getPrivate();
		PublicKey pubkeyV = kpV.getPublic();
		
		System.out.println("User V : "+privkeyV.toString());
		System.out.println("User V : "+pubkeyV.toString());
		
		
		KeyAgreement ecdhU = KeyAgreement.getInstance("ECDH");
		ecdhU.init(privkeyU);
		ecdhU.doPhase(pubkeyV, true);
		
		KeyAgreement ecdhV = KeyAgreement.getInstance("ECDH");
		ecdhV.init(privkeyV);
		ecdhV.doPhase(pubkeyU, true);
		
		System.out.println("Secret computed by U : 0x"+(new BigInteger(1,ecdhU.generateSecret()).toString(16)).toUpperCase());		
		System.out.println("Secret computed by V : 0x"+(new BigInteger(1,ecdhV.generateSecret()).toString(16)).toUpperCase());
		
		BigInteger xyz = new BigInteger(1,ecdhU.generateSecret());
		System.out.println("\n\nSecret computed by User : "+xyz.toString(16).toUpperCase());
		
		return xyz;
	}
	
	private static String bytesToString(byte[] message)
	{
		String temp="";
		for(byte b : message)
			temp+= Byte.toString(b);
		
		return temp;
	}
	
	public byte[] encrypt(byte[] message)
	{
		return (new BigInteger(message).modPow(e, N).toByteArray());	 // C = M^e mod N
	}
	
	public byte[] decrypt(byte[] cipher)
	{
		return (new BigInteger(cipher).modPow(d, N).toByteArray());	// M = C^d mod N
	}
	
	
	@SuppressWarnings("deprecation")
	public static void main(String[] args) throws Exception
	{
		System.out.println("8th Semester Project -> Hybrid Cryptography Algorithm : \n");

		HybridAlgorithm obj = new HybridAlgorithm();
		String input="";
		DataInputStream in = new DataInputStream(System.in);
		
		System.out.println("\nEnter the input string : ");
		input = in.readLine();
		
		System.out.println("The input string : "+input);
		System.out.println("The Input (in bytes) : "+ bytesToString(input.getBytes()));
		
		byte[] cipherText = obj.encrypt(input.getBytes());
		System.out.println("\nThe Cipher  : " + bytesToString(cipherText));
		
		byte[] decryptedText = obj.decrypt(cipherText);
		String Message = new String(decryptedText);
		System.out.println("\nThe Message (In Bytes) : "+bytesToString(decryptedText));
		System.out.println("The Message : "+Message);		
		
	}
}

